package dbfit.util;

import fit.TypeAdapter;
/* this class addresses several issues with parsing, and is used as a base for any other dbfit type adapters:
 * 1: TypeAdapter does not check the parse delegates directly when parsing, it relies on appropriate delegate
 * 	being selected when adapter is created; this creates problems for dbfit adapters which need to delegate parsing
 *     to appropriate types, but access values from sql parameters etc
 *  2: this class encapsulates symbol access using <<
 *  3: some db drivers will return different numeric types for the same column depending on use (in view, autogenerated..);
 *  	this adapter tries to fix inconsistent types first by casting, then by parsing if needed
 * 
 */

public class ParseHelper {
    private Class<?> type;
    private TypeAdapter typeAdapter;

    public ParseHelper(TypeAdapter typeAdapter, Class<?> type) {
        this.type = type;
        this.typeAdapter = typeAdapter;
    }

    public Object parse(String s) throws Exception {
        ContentOfTableCell content = new ContentOfTableCell(s);
        if (content.isNull()) {
            return null;
        } else if (content.isSymbolGetter()) {
            return SymbolUtil.getSymbol(s, type);
        } else if (this.type.equals(String.class) && content.doesFixedLengthParsingApply()) {
            return content.getFixedLengthParsedString();
        } else {
            return typeAdapter.parse(s);
        }
    }
}
